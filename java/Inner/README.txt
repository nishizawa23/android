Inner_Conventional:常规内部类
       1.内部类就像一个实例成员一样存在于外部类中。
       2.内部类可以访问外部类的所有成员就想访问自己的成员一样没有限制。
       3.内部类中的this指的是内部类的实例对象本身，如果要用外部类的实例对象就可以用类名.this
         的方式获得。
       4.内部类对象中不能有静态成员，原因很简单，内部类的实例对象是外部类实例对象的一个成员。

       下面我们再小结一下内部类的创建方法：
       1.在外部类的内部，可以用 Inner inner = new Inner(); 方法直接创建
       2.在外部类外部，必须先创建外部类实例，然后再创建内部类实例，除了上面 Inner inner =
         new Outer().new Inner()的写法以外还有 Outer outer = new Outer(); Inner inner =
         outer.new Inner();的写法

Inner_Portion：局部内部类
      1.局部内部类的地位和方法和类的局部变量的位置类似，因此不能修饰局部变量的修饰符也不能修饰局
        部内部类，譬如public、private、protected、static、transient等
      2.局部内部类只能在声明的方法内是可见的，因此定义局部内部类之后，想用的话就要在方法内直接
        实例化，记住这里顺序不能反了，一定是要先声明后使用，否则编译器会说找不到。
      3.局部内部类不能访问定义它的方法内的局部变量，除非这个变量被定义为final 。

Inner_Anonymous:匿名内部类
       当我们把内部类的定义和声明写到一起时，就不用给这个类起个类名而是直接使用了，这种形式的内部类根本就没有类名，因此我们叫它匿名内部类。
       1.第一匿名内部类可以是个接口.
       2.匿名内部类用 new Pet(){ … } 的方式把声明类的过程和创建类的实例的过程合二为一。
       3.匿名内部类可以是某个类的继承子类也可以是某个接口的实现类

Inner_Static:静态内部类
       需要了解2个概念：内部类和静态修饰符static
       1）首先，用内部类是因为内部类与所在外部类有一定的关系，往往只有该外部类调用此内部类。所以没有必要专门用一个Java文件存放这个类。
       2）静态都是用来修饰类的内部成员的。比如静态方法，静态成员变量，静态常量。它唯一的作用就是随着类的加载（而不是随着对象的产生）而产生，以致可以用类名+静态成员名直接获得。
          这样静态内部类就可以理解了，因为这个类没有必要单独存放一个文件，它一般来说只被所在外部类使用。并且它可以直接被用 外部类名+内部类名 获得。

       以下举例说明怎么使用：
       Student类有个叫School的内部类（非静态）
       Student stu = new Student();
       stu.School sch = new stu.School();
       sch就是School的一个对象。

       假如School是内部静态类：
       Student.School sch = new Student.School();
